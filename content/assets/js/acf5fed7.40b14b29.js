"use strict";(self.webpackChunkrocketmq_docs=self.webpackChunkrocketmq_docs||[]).push([[9414],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>p});var n=a(67294);function s(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){s(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,s=function(e,t){if(null==e)return{};var a,n,s={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(s[a]=e[a]);return s}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(s[a]=e[a])}return s}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,s=e.mdxType,r=e.originalType,c=e.parentName,m=i(e,["components","mdxType","originalType","parentName"]),h=l(a),d=s,p=h["".concat(c,".").concat(d)]||h[d]||u[d]||r;return a?n.createElement(p,o(o({ref:t},m),{},{components:a})):n.createElement(p,o({ref:t},m))}));function p(e,t){var a=arguments,s=t&&t.mdxType;if("string"==typeof e||s){var r=a.length,o=new Array(r);o[0]=d;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i[h]="string"==typeof e?e:s,o[1]=i;for(var l=2;l<r;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},82711:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>u,frontMatter:()=>r,metadata:()=>i,toc:()=>l});var n=a(87462),s=(a(67294),a(3905));const r={},o="Transaction Message",i={unversionedId:"featureBehavior/04transactionmessage",id:"version-5.0/featureBehavior/04transactionmessage",title:"Transaction Message",description:"Transactional messages are an advanced message type in Apache RocketMQ. This topic describes the application scenarios, working mechanism, limits, usage, and usage notes of transactional messages.",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-5.0/04-featureBehavior/04transactionmessage.md",sourceDirName:"04-featureBehavior",slug:"/featureBehavior/04transactionmessage",permalink:"/docs/featureBehavior/04transactionmessage",draft:!1,editUrl:"https://github.com/apache/rocketmq-site/tree/new-official-website/versioned_docs/version-5.0/04-featureBehavior/04transactionmessage.md",tags:[],version:"5.0",frontMatter:{},sidebar:"version-5.0/myAutogeneratedSidebar",previous:{title:"Ordered Message",permalink:"/docs/featureBehavior/03fifomessage"},next:{title:"Sending Retry and Throttling Policy",permalink:"/docs/featureBehavior/05sendretrypolicy"}},c={},l=[{value:"Scenarios",id:"scenarios",level:2},{value:"Working mechanism",id:"working-mechanism",level:2},{value:"Usage limits",id:"usage-limits",level:2},{value:"Example",id:"example",level:2},{value:"Usage notes",id:"usage-notes",level:2}],m={toc:l},h="wrapper";function u(e){let{components:t,...r}=e;return(0,s.kt)(h,(0,n.Z)({},m,r,{components:t,mdxType:"MDXLayout"}),(0,s.kt)("h1",{id:"transaction-message"},"Transaction Message"),(0,s.kt)("p",null,"Transactional messages are an advanced message type in Apache RocketMQ. This topic describes the application scenarios, working mechanism, limits, usage, and usage notes of transactional messages."),(0,s.kt)("h2",{id:"scenarios"},"Scenarios"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Distributed transactions")),(0,s.kt)("p",null,"When a core business logic is executed in a distributed system, multiple downstream businesses are invoked to process the logic simultaneously. Therefore, ensuring the consistency of the execution results between the core business and the downstream businesses is the biggest challenge that needs to be solved for distributed transactions.\n",(0,s.kt)("img",{alt:"\u4e8b\u52a1\u6d88\u606f\u8bc9\u6c42",src:a(79977).Z,width:"871",height:"400"})),(0,s.kt)("p",null,"In an e-commerce scenario, when a user places an order, downstream systems are triggered to make changes accordingly. For example, the logistics system must initiate shipment, the credit system must update the user's credit points, and the shopping cart system must clear the user's shopping cart. The processing branches include:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The order system changes the order status from unpaid to paid.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The logistics system adds a to-be-shipped record and creates an order logistics record.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The credit system updates the credit points of the user.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The shopping cart system clears the shopping cart and updates the user's shopping cart records."))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Traditional XA-based solution: poor performance")),(0,s.kt)("p",null,"The typical method used to ensure result consistency among the branches is by using a distributed transaction system based on the eXtended Architecture (XA) protocol. The system encapsulates the four call branches into a large transaction that contains four independent transaction branches. While this solution can ensure result consistency, a large number of resources need to be locked to achieve this. This number increases with the number of branches, which results in low system concurrency. As more downstream branches are added, the system performance deteriorates."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Normal message-based solution: poor result consistency")),(0,s.kt)("p",null,"A simpler solution based on the XA solution treats the change of the order system as a local transaction and the changes of downstream systems as downstream tasks. Transaction branches are treated as normal messages with added order table transactions. This solution processes messages asynchronously to shorten the processing lifecycle and improves system concurrency. ",(0,s.kt)("img",{alt:"\u666e\u901a\u6d88\u606f\u65b9\u6848",src:a(66770).Z,width:"1070",height:"727"})),(0,s.kt)("p",null,"However, this solution is prone to deliver inconsistent results between the core transaction and transaction branches, for example:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The message is sent, but the order is not executed. As a result, the whole transaction needs to be rolled back.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"The order is executed, but the message is not sent. In this case, the message has to be resent for consumption.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Timeout errors cannot be reliably detected, which makes it difficult to determine whether the order needs to be rolled back or an order change needs to be committed."))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Distributed transaction message-based solution of Apache RocketMQ: thorough consistency")),(0,s.kt)("p",null,"The reason why consistency cannot be guaranteed in the preceding solution is that normal messages do not have the commit, rollback, and unified coordination capabilities of standalone database transactions."),(0,s.kt)("p",null,"The transactional message feature of Apache RocketMQ supports two-phase commit on the basis of the normal message-based solution. The feature combines two-phase commit and local transaction to achieve global consistency of commit results.\n",(0,s.kt)("img",{alt:"\u4e8b\u52a1\u6d88\u606f",src:a(62576).Z,width:"1070",height:"727"})),(0,s.kt)("p",null,"The transactional message solution of Apache RocketMQ is powerful, scalable, and easy to develop. For more information about the working mechanism and process of transactional message, see Working mechanism\u3002"),(0,s.kt)("h2",{id:"working-mechanism"},"Working mechanism"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Definition")),(0,s.kt)("p",null,"Transactional messages are an advanced message type provided by Apache RocketMQ to ensure the ultimate consistency between message production and local transaction.\n",(0,s.kt)("strong",{parentName:"p"},"Processing workflow")),(0,s.kt)("p",null,"The following figure shows the interaction process of transactional messages.",(0,s.kt)("img",{alt:"\u4e8b\u52a1\u6d88\u606f",src:a(57344).Z,width:"1989",height:"633"})),(0,s.kt)("ol",null,(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"The producer sends a message to a Apache RocketMQ broker.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"The Apache RocketMQ broker saves the message and marks it as not ready for delivery. A message in this state is called a half message. After that, the broker sends an acknowledgment message (ACK) back to the producer.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"The producer executes the local transaction.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"The producer sends a second ACK to the broker to submit the execution result of the local transaction. The execution result may be Commit or Rollback."),(0,s.kt)("ul",{parentName:"li"},(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"If the status of the message received by the broker is Commit, the broker marks the half message as deliverable and delivers the message to the consumer.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"If the status of the message received by the broker is Rollback, the broker rolls back the transaction and does not deliver the half message to the consumer."))))),(0,s.kt)("ol",{start:5},(0,s.kt)("li",{parentName:"ol"},"If the network is disconnected or the producer application is restarted and the broker does not receive a second ACK or the status of the half message is Unknown, the broker waits a period of time and sends a request to a producer in the producer cluster to query the status of the half message.\n",(0,s.kt)("strong",{parentName:"li"},"Note")," For more information about the length of the period and the maximum number of queries, see",(0,s.kt)("a",{parentName:"li",href:"/docs/introduction/03limits"},"Parameter limits"),".")),(0,s.kt)("ol",{start:6},(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"After the producer receives the request, the producer checks the execution result of the local transaction that corresponds to the half message.")),(0,s.kt)("li",{parentName:"ol"},(0,s.kt)("p",{parentName:"li"},"The producer sends another ACK to the Apache RocketMQ broker based on the execution result of the local transaction. Then, the broker processes the half message by following Step 4."))),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Lifecycle of a transactional message"),"\n",(0,s.kt)("img",{alt:"\u4e8b\u52a1\u6d88\u606f",src:a(59378).Z,width:"1183",height:"218"})),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Initialized: The message is built and initialized by the producer and is ready to be sent to a broker.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Transaction pending: The half message is sent to the broker. However, it is not immediately written to a disk for permanent storage. Instead, it is stored in a transaction storage system. The message is not committed until the system verifies that the second phase of the local transaction is successful. During this period, the message is invisible to downstream consumers.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Rollback: In the second phase, if the execution result of the transaction is rollback, the broker rolls back the half message and terminates the workflow.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Ready: The message is sent to the broker, and is visible to the consumer and available for consumption.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Inflight: The message is obtained by the consumer and processed based on the local business logic of the consumer."),(0,s.kt)("p",{parentName:"li"},"In this process, the broker waits for the consumer to complete the consumption and submit the consumption result. If no response is received from the consumer in a certain period of time, Apache RocketMQ retries the message. For more information, see ",(0,s.kt)("a",{parentName:"p",href:"/docs/featureBehavior/10consumerretrypolicy"},"Consumption retry"),".")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Acked: The consumer completes consumption and submits the consumption result to the broker. The broker marks whether the current message is successfully consumed."),(0,s.kt)("p",{parentName:"li"},"By default, Apache RocketMQ retains all messages. When the consumption result is submitted, the message data is logically marked as consumed instead of being deleted immediately. Therefore, the consumer can backtrack the message for re-consumption before it is deleted due to the expiration of the retention period or insufficient storage space.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Deleted: When the retention period of the message expires or the storage space is insufficient, Apache RocketMQ deletes the earliest saved message from the physical file in a rolling manner. For more information, see ",(0,s.kt)("a",{parentName:"p",href:"/docs/featureBehavior/11messagestorepolicy"},"Message storage and cleanup"),"."))),(0,s.kt)("h2",{id:"usage-limits"},"Usage limits"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Message type consistency")),(0,s.kt)("p",null,"Transactional messages can only be used in topics whose MessageType is Transaction."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Transaction-centered consumption")),(0,s.kt)("p",null,"The transactional message feature of Apache RocketMQ guarantees that the same transaction can be processed between the local core transaction and downstream branches. However, it does not guarantee the consistency between the message consumption result and the upstream execution result. Therefore, downstream businesses must ensure that messages are processed correctly. We recommend that consumers ",(0,s.kt)("a",{parentName:"p",href:"/docs/featureBehavior/10consumerretrypolicy"},"Consumption retry")," properly to ensure that the message is processed correctly in the event of failure."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Intermediate state visibility")),(0,s.kt)("p",null,"The transactional message feature of Apache RocketMQ ensures only final consistency, which means that status consistency is not guaranteed between an upstream transaction and a downstream branch before a message is delivered to a consumer. Therefore, transactional messages are only suitable for transaction scenarios that accept asynchronous execution."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Transaction timeout mechanism")),(0,s.kt)("p",null,"Apache RocketMQ implements a timeout mechanism for transactional messages. Upon receiving a half message, if the broker cannot determine whether to commit or roll back the transaction after a certain period of time, the broker rolls back the message by default. For more information about the timeout period, see",(0,s.kt)("a",{parentName:"p",href:"/docs/introduction/03limits"},"Parameter limits"),"."),(0,s.kt)("h2",{id:"example"},"Example"),(0,s.kt)("p",null,"Sending transactional messages is different from sending normal messages in the following aspects:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Before sending transactional messages, you must enable the transaction checker and associate it with local transaction execution.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"When creating a producer, you must set the transaction checker and bind the list of topics of messages to be sent. These actions enable the built-in transaction checker of the client to restore topics in the event of exceptions."))),(0,s.kt)("p",null,"The following example uses Java as an example to show you how to send transactional messages:"),(0,s.kt)("pre",null,(0,s.kt)("code",{parentName:"pre",className:"language-java"},'    // The demo is used to simulate the order table query service to check whether the order transaction is submitted. \n    private static boolean checkOrderById(String orderId) {\n        return true;\n    }\n    // The demo is used to simulate the execution result of a local transaction. \n    private static boolean doLocalTransaction() {\n        return true;\n    }\n    public static void main(String[] args) throws ClientException {\n        ClientServiceProvider provider = new ClientServiceProvider();\n        MessageBuilder messageBuilder = new MessageBuilder();\n        // Build a transaction producer: The transactional message requires the producer to build a transaction checker to check the intermediate status of an exceptional half message. \n        Producer producer = provider.newProducerBuilder()\n                .setTransactionChecker(messageView -> {\n                    /**\n                     * The transaction checker checks whether the local transaction is correctly committed or rolled back based on the business ID, for example, an order ID. \n                     * If this order is found in the order table, the order insertion action is committed correctly by the local transaction. If no order is found in the order table, the local transaction has been rolled back. \n                     */\n                    final String orderId = messageView.getProperties().get("OrderId");\n                    if (Strings.isNullOrEmpty(orderId)) {\n                        // Message error. Rollback is returned. \n                        return TransactionResolution.ROLLBACK;\n                    }\n                    return checkOrderById(orderId) ? TransactionResolution.COMMIT : TransactionResolution.ROLLBACK;\n                })\n                .build();\n        // Create a transaction branch. \n        final Transaction transaction;\n        try {\n            transaction = producer.beginTransaction();\n        } catch (ClientException e) {\n            e.printStackTrace();\n            // If the transaction branch fails to be created, the transaction is terminated. \n            return;\n        }\n        Message message = messageBuilder.setTopic("topic")\n                // Specify the message index key so that the system can use a keyword to accurately locate the message. \n                .setKeys("messageKey")\n                // Specify the message tag so that consumers can use the tag to filter the message. \n                .setTag("messageTag")\n                // For transactional messages, a unique ID associated with the local transaction is created to verify the query of the local transaction status. \n                .addProperty("OrderId", "xxx")\n                // Message body. \n                .setBody("messageBody".getBytes())\n                .build();\n        // Send a half message.\n        final SendReceipt sendReceipt;\n        try {\n            sendReceipt = producer.send(message, transaction);\n        } catch (ClientException e) {\n            // If the half message fails to be sent, the transaction can be terminated and the message is rolled back. \n            return;\n        }\n        /**\n         * Execute the local transaction and check the execution result. \n         * 1. If the result is Commit, deliver the message. \n         * 2. If the result is Rollback, roll back the message. \n         * 3. If an unknown exception occurs, no action is performed until a response is obtained from a half message status query. \n         *\n         */\n        boolean localTransactionOk = doLocalTransaction();\n        if (localTransactionOk) {\n            try {\n                transaction.commit();\n            } catch (ClientException e) {\n                // You can determine whether to retry the message based on your business requirements. If you do not want to retry the message, you can use the half message status query to submit the transaction status. \n                e.printStackTrace();\n            }\n        } else {\n            try {\n                transaction.rollback();\n            } catch (ClientException e) {\n                // We recommend that you record the exception information. This enables you to submit the transaction status based on the half message status query in the event of a rollback exception. Otherwise, you have to retry the message. \n                e.printStackTrace();\n            }\n        }\n    }\n')),(0,s.kt)("h2",{id:"usage-notes"},"Usage notes"),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Avoid timeout of a large number of half messages.")),(0,s.kt)("p",null,"Apache RocketMQ allows you to check the transaction in the event of an exception during a transaction commit to ensure transaction consistency. However, producers should try to avoid local transactions returning unknown results. A large number of transaction checks can cause system performance to deteriorate and delay transaction processing."),(0,s.kt)("p",null,(0,s.kt)("strong",{parentName:"p"},"Properly handle transactions in progress.")),(0,s.kt)("p",null,"During a half message status query, do not return Rollback or Commit for a transaction in progress. Instead, keep the Unknown status for the transaction."),(0,s.kt)("p",null,"Generally, the reason why the transaction is in progress is that the transaction execution is slow and the query is frequent. Two solutions are recommended:"),(0,s.kt)("ul",null,(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Set the interval for the first query to a larger value. However, this may cause a large delay for messages that depend on the query result.")),(0,s.kt)("li",{parentName:"ul"},(0,s.kt)("p",{parentName:"li"},"Make the program correctly identify ongoing transactions."))))}u.isMDXComponent=!0},59378:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/lifecyclefortrans-fe4a49f1c9fdae5d590a64546722036f.png"},79977:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tradetrans01-636d42fb6584de6c51692d0889af5c2d.png"},62576:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/tradewithtrans-25be17fcdedb8343a0d2633e693d126d.png"},57344:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/transflow-0b07236d124ddb814aeaf5f6b5f3f72c.png"},66770:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/transwithnormal-f7d951385520fc18aea8d85f0cd86c27.png"}}]);