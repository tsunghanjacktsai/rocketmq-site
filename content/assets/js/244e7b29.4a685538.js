"use strict";(self.webpackChunkrocketmq_docs=self.webpackChunkrocketmq_docs||[]).push([[2353],{3905:(e,s,t)=>{t.d(s,{Zo:()=>l,kt:()=>g});var r=t(67294);function a(e,s,t){return s in e?Object.defineProperty(e,s,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[s]=t,e}function n(e,s){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);s&&(r=r.filter((function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var s=1;s<arguments.length;s++){var t=null!=arguments[s]?arguments[s]:{};s%2?n(Object(t),!0).forEach((function(s){a(e,s,t[s])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):n(Object(t)).forEach((function(s){Object.defineProperty(e,s,Object.getOwnPropertyDescriptor(t,s))}))}return e}function i(e,s){if(null==e)return{};var t,r,a=function(e,s){if(null==e)return{};var t,r,a={},n=Object.keys(e);for(r=0;r<n.length;r++)t=n[r],s.indexOf(t)>=0||(a[t]=e[t]);return a}(e,s);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)t=n[r],s.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var m=r.createContext({}),u=function(e){var s=r.useContext(m),t=s;return e&&(t="function"==typeof e?e(s):o(o({},s),e)),t},l=function(e){var s=u(e.components);return r.createElement(m.Provider,{value:s},e.children)},p="mdxType",c={inlineCode:"code",wrapper:function(e){var s=e.children;return r.createElement(r.Fragment,{},s)}},d=r.forwardRef((function(e,s){var t=e.components,a=e.mdxType,n=e.originalType,m=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),p=u(t),d=a,g=p["".concat(m,".").concat(d)]||p[d]||c[d]||n;return t?r.createElement(g,o(o({ref:s},l),{},{components:t})):r.createElement(g,o({ref:s},l))}));function g(e,s){var t=arguments,a=s&&s.mdxType;if("string"==typeof e||a){var n=t.length,o=new Array(n);o[0]=d;var i={};for(var m in s)hasOwnProperty.call(s,m)&&(i[m]=s[m]);i.originalType=e,i[p]="string"==typeof e?e:a,o[1]=i;for(var u=2;u<n;u++)o[u]=t[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}d.displayName="MDXCreateElement"},15810:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>m,contentTitle:()=>o,default:()=>c,frontMatter:()=>n,metadata:()=>i,toc:()=>u});var r=t(87462),a=(t(67294),t(3905));const n={},o="Ordered Message",i={unversionedId:"featureBehavior/03fifomessage",id:"version-5.0/featureBehavior/03fifomessage",title:"Ordered Message",description:"Ordered messages are a type of message with advanced features in Apache RocketMQ. This topic describes the scenarios, working mechanism, limits, usage examples, and usage notes of ordered messages.",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-5.0/04-featureBehavior/03fifomessage.md",sourceDirName:"04-featureBehavior",slug:"/featureBehavior/03fifomessage",permalink:"/docs/featureBehavior/03fifomessage",draft:!1,editUrl:"https://github.com/apache/rocketmq-site/tree/new-official-website/versioned_docs/version-5.0/04-featureBehavior/03fifomessage.md",tags:[],version:"5.0",frontMatter:{},sidebar:"version-5.0/myAutogeneratedSidebar",previous:{title:"Delay Message",permalink:"/docs/featureBehavior/02delaymessage"},next:{title:"Transaction Message",permalink:"/docs/featureBehavior/04transactionmessage"}},m={},u=[{value:"Scenarios",id:"scenarios",level:2},{value:"Working mechanism",id:"working-mechanism",level:2},{value:"Usage limits",id:"usage-limits",level:2},{value:"Example",id:"example",level:2},{value:"Usage notes",id:"usage-notes",level:2}],l={toc:u},p="wrapper";function c(e){let{components:s,...n}=e;return(0,a.kt)(p,(0,r.Z)({},l,n,{components:s,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"ordered-message"},"Ordered Message"),(0,a.kt)("p",null,"Ordered messages are a type of message with advanced features in Apache RocketMQ. This topic describes the scenarios, working mechanism, limits, usage examples, and usage notes of ordered messages."),(0,a.kt)("h2",{id:"scenarios"},"Scenarios"),(0,a.kt)("p",null,"Heterogeneous systems use state synchronization to maintain strong consistency in scenarios such as ordered event processing, transaction matchmaking, and real-time incremental data synchronization. The preceding scenarios require ordered delivery of messages from upstream applications to downstream applications when an event change occurs. Apache RocketMQ provides ordered messages to help you implement ordered message transmission."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Scenario 1: Transaction matchmaking"),"\n",(0,a.kt)("img",{alt:"\u4ea4\u6613\u64ae\u5408",src:t(20521).Z,width:"877",height:"459"})),(0,a.kt)("p",null,"For example, in securities and stock trading scenarios, if multiple bidders offer the same bid price for a bid order, the bidder who first offers the bid price wins the bid. Therefore, the downstream order processing system must be designed to process orders in the order in which prices were offered."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Scenario 2: Real-time incremental data synchronization")),(0,a.kt)("p",null,"Normal message",(0,a.kt)("img",{alt:"\u666e\u901a\u6d88\u606f",src:t(57939).Z,width:"964",height:"537"}),"\nFifo message",(0,a.kt)("img",{alt:"\u987a\u5e8f\u6d88\u606f",src:t(40046).Z,width:"964",height:"537"})),(0,a.kt)("p",null,"For example, you want to perform incremental synchronization of data that is related to database modifications. You can use ordered messages provided in Apache RocketMQ to transmit messages from the upstream source database to the downstream query system. The messages can be binary logs of addition, deletion, and modification operations. The downstream system retrieves the messages in the order in which the messages are sent to make the database status updated in the same order. Ordered messages help you ensure consistency between the operations in the upstream system and the status data in the downstream system. If you use normal messages in this scenario, state inconsistency may occur."),(0,a.kt)("h2",{id:"working-mechanism"},"Working mechanism"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Definition of ordered messages")),(0,a.kt)("p",null,"Ordered messages are an advanced type of message in Apache RocketMQ. Ordered messages are delivered to consumers in the order in which the messages are sent. This message type allows you to implement ordered processing in business scenarios."),(0,a.kt)("p",null,"The defining characteristics of ordered messages are the order of message sending, storage, and delivery."),(0,a.kt)("p",null,"Apache RocketMQ uses message groups to determine the order of ordered messages. You must configure message groups for ordered messages. The messages in a message group are processed in the first-in, first-out (FIFO) order. Message ordering does not apply to different message groups or messages that are not in a message group."),(0,a.kt)("p",null,"Message group-based message ordering allows you to specify fine-grained message ordering based on your business logic. This helps you implement partial message ordering in your business system and improve the degree of concurrency and throughput of the business system."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Message ordering")),(0,a.kt)("p",null,"Two types of message order apply in Apache RocketMQ: the production order and the consumption order."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Production order")," \uff1a Apache RocketMQ uses the protocol that is established between the producer and the server to ensure that messages are serially sent from the producer to the server and that the messages are stored and persisted in the order in which the messages are sent."),(0,a.kt)("p",{parentName:"li"},"To ensure the production order of messages, make sure that the following conditions are met:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Single producer: The production order of messages applies to individual producers. Apache RocketMQ cannot determine the order of messages from different producers in different systems, even if you configure the same message group for the messages.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Serial transmission: A producer in Apache RocketMQ supports secure access by using multiple threads. If a producer uses multiple threads to concurrently send messages, Apache RocketMQ cannot determine the order of messages from different threads."))))),(0,a.kt)("p",null,"If producers that meet the preceding conditions send messages to Apache RocketMQ, the messages that belong to the same message group are stored in the same queue in the order in which the messages are sent. The following figure describes the sequential storage logic of Apache RocketMQ."),(0,a.kt)("p",null,(0,a.kt)("img",{alt:"\u987a\u5e8f\u5b58\u50a8\u903b\u8f91",src:t(13638).Z,width:"1587",height:"843"})),(0,a.kt)("p",null,"In the preceding figure, messages from MessageGroup 1 and MessageGroup 4 are stored in the same queue (MessageQueue 1). Apache RocketMQ ensures that messages G1-M1, G1-M2, and G1-M3 from MessageGroup 1 are stored in the queue in the order in which the messages are sent. Messages G4-M1 and G4-M2 from MessageGroup 4 are also stored in the order in which the messages are sent. However, messages from MessageGroup 1 and MessageGroup 4 are stored in no particular order."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},(0,a.kt)("strong",{parentName:"p"},"Consumption order")," \uff1a"),(0,a.kt)("p",{parentName:"li"},"Apache RocketMQ uses the protocol that is established between the consumers and the server to ensure that messages are consumed in the order in which the messages are stored."),(0,a.kt)("p",{parentName:"li"},"To ensure the consumption order of messages, make sure that the following conditions are met:"),(0,a.kt)("ul",{parentName:"li"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Delivery order: Apache RocketMQ ensures that message are delivered in the message storage order on the server by using the client SDK and the communications protocol on the server side. When consumer applications consume messages, the applications must follow the receive-process-reply path to prevent out-of-order messages caused by asynchronous processing."),(0,a.kt)("admonition",{parentName:"li",type:"note"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},"When a PushConsumer consumer consumes messages, Apache RocketMQ ensures that messages are delivered to the consumer one by one in the order in which the messages are stored. "),(0,a.kt)("li",{parentName:"ul"},"When a SimpleConsumer consumer consumes messages, the consumer may pull multiple messages at a time, and the business application must have a solution to implement the message consumption order. For more information about consumer types, see ",(0,a.kt)("a",{parentName:"li",href:"/docs/featureBehavior/06consumertype"},"Consumer types"),".")))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Limited retries:Apache RocketMQ limits the number of delivery retries for ordered messages. If a message reaches the maximum number of delivery retries, Apache RocketMQ stops retrying the delivery of the message for consumption. This prevents other messages in the queue from constantly waiting for delivery."))),(0,a.kt)("p",{parentName:"li"},"In scenarios in which the consumption order is critical, we recommend that you specify an appropriate number of retries to prevent out-of-order message processing."))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Combination of production order and consumption order")),(0,a.kt)("p",null,"If you want messages to be processed based on the FIFO principle, the production order and the consumption order are required. In most business scenarios, a producer may map to multiple consumers, and not all consumers require ordered consumption of messages. You can combine the settings of production order and consumption order to meet your requirements in different business scenarios. For example, you can send ordered messages and use non-sequential concurrent consumption to improve throughput. The following table describes different combinations of production order and consumption order settings."),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"Production order"),(0,a.kt)("th",{parentName:"tr",align:null},"Consumption order"),(0,a.kt)("th",{parentName:"tr",align:null},"Effect"))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Configure message groups to implement ordered delivery of messages."),(0,a.kt)("td",{parentName:"tr",align:null},"Ordered consumption of messages"),(0,a.kt)("td",{parentName:"tr",align:null},"The order of messages is ensured at the message group level. Messages in the same message group are sent and consumed in the same order.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Configure message groups to implement ordered delivery of messages."),(0,a.kt)("td",{parentName:"tr",align:null},"Concurrent consumption"),(0,a.kt)("td",{parentName:"tr",align:null},"Messages are concurrently and chronologically consumed.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Configure no message groups to implement unordered delivery of messages."),(0,a.kt)("td",{parentName:"tr",align:null},"Ordered consumption of messages"),(0,a.kt)("td",{parentName:"tr",align:null},"The order of messages is ensured at the queue level. The message consumption is based on the attributes of the queue. Apache RocketMQ ensures that the consumption order is the same as the storage order in the queue, but not necessarily the same as the message sending order.")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"Configure no message groups to implement unordered delivery of messages."),(0,a.kt)("td",{parentName:"tr",align:null},"Concurrent consumption"),(0,a.kt)("td",{parentName:"tr",align:null},"Messages are concurrently and chronologically consumed.")))),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Lifecycle of an ordered message"),"\n",(0,a.kt)("img",{alt:"\u751f\u547d\u5468\u671f",src:t(43493).Z,width:"870",height:"106"})),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Initialized: The message is built and initialized by the producer and is ready to be sent to a broker.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Ready: The message is sent to the broker, and is visible to the consumer and available for consumption.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Inflight: The message is obtained by the consumer and processed based on the local business logic of the consumer."),(0,a.kt)("p",{parentName:"li"},"In this process, the broker waits for the consumer to complete the consumption and submit the consumption result. If no response is received from the consumer in a certain period of time, Apache RocketMQ retries the message. For more information, see ",(0,a.kt)("a",{parentName:"p",href:"/docs/featureBehavior/10consumerretrypolicy"},"Consumption retry"),".")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Acked: The consumer completes consumption and submits the consumption result to the broker. The broker marks whether the current message is successfully consumed."),(0,a.kt)("p",{parentName:"li"},"By default, Apache RocketMQ retains all messages. When the consumption result is submitted, the message data is logically marked as consumed instead of being deleted immediately. Therefore, the consumer can backtrack the message for re-consumption before it is deleted due to the expiration of the retention period or insufficient storage space.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Deleted: When the retention period of the message expires or the storage space is insufficient, Apache RocketMQ deletes the earliest saved message from the physical file in a rolling manner. For more information, see ",(0,a.kt)("a",{parentName:"p",href:"/docs/featureBehavior/11messagestorepolicy"},"Message storage and cleanup"),"."))),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("ul",{parentName:"admonition"},(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"Message consumption failures or timeouts trigger the retry logic of the server. If a consumption retry is triggered for a message, the message reaches the end of its lifecycle. The original message is considered a new message with a new message ID.")),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"If a consumption retry is triggered for an ordered message, the messages that follow the ordered message can be processed only after the ordered message is consumed.")))),(0,a.kt)("h2",{id:"usage-limits"},"Usage limits"),(0,a.kt)("p",null,"Ordered messages support only topics whose MessageType is FIFO."),(0,a.kt)("h2",{id:"example"},"Example"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Create topic")),(0,a.kt)("p",null,"For creating topics in Apache RocketMQ 5.0, it is recommended to use the mqadmin tool. However, it is worth noting that message type needs to be added as a property parameter. Here is an example:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-shell"},"sh mqadmin updateTopic -n <nameserver_address> -t <topic_name> -c <cluster_name> -a +message.type=FIFO\n")),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Send messages")),(0,a.kt)("p",null,"Compared with normal messages, ordered messages must have message groups configured for them. We recommend that you configure message groups at a fine-grained level based on your business requirements to allow for workload decoupling and concurrency scaling."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Create FIFO Topic")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"./bin/mqadmin updateTopic -c DefaultCluster -t FIFOTopic -o true -n 127.0.0.1:9876\n")),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"-c the cluster name"),(0,a.kt)("li",{parentName:"ul"},"-t the topic name"),(0,a.kt)("li",{parentName:"ul"},"-n the address of the nameserver"),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("strong",{parentName:"li"},"-o the flag to create a ordered Topic"))),(0,a.kt)("p",null,"The following sample code provides an example on how to send and receive ordered messages in Java:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-java"},'        // Send ordered messages. \n        MessageBuilder messageBuilder = null;\n        Message message = messageBuilder.setTopic("topic")\n                // Specify the message index key. The system uses the key to locate the message. \n                .setKeys("messageKey")\n                // Specify the message tag. The consumer can use the tag to filter the message. \n                .setTag("messageTag")\n                // Configure a message group for the ordered messages. We recommend that you do not include a large number of messages in the group. \n                .setMessageGroup("fifoGroup001")\n                // Configure the message body. \n                .setBody("messageBody".getBytes())\n                .build();\n        try {\n            // Send the messages. Focus on the result of message sending and exceptions such as failures.\n            SendReceipt sendReceipt = producer.send(message);\n            System.out.println(sendReceipt.getMessageId());\n        } catch (ClientException e) {\n            e.printStackTrace();\n        }\n        // Make sure that ordered delivery is applied to the consumer group. Otherwise, the messages are delivered concurrently and in no particular order. \n        // Consumption example 1: If the consumer type is PushConsumer, the consumer needs to only process the message in the message listener. \n        MessageListener messageListener = new MessageListener() {\n            @Override\n            public ConsumeResult consume(MessageView messageView) {\n                System.out.println(messageView);\n                // Return the status based on the consumption result. \n                return ConsumeResult.SUCCESS;\n            }\n        };\n        // Consumption example 2: If the consumer type is SimpleConsumer, the consumer must actively obtain the message for consumption and submit the consumption result. \n        // If the consumption of a message in the message group has not finished, the next message in the message group cannot be retrieved if you call the Receive function. \n        List<MessageView> messageViewList = null;\n        try {\n            messageViewList = simpleConsumer.receive(10, Duration.ofSeconds(30));\n            messageViewList.forEach(messageView -> {\n                System.out.println(messageView);\n                // After consumption is complete, the consumer must invoke ACK to submit the consumption result. \n                try {\n                    simpleConsumer.ack(messageView);\n                } catch (ClientException e) {\n                    e.printStackTrace();\n                }\n            });\n        } catch (ClientException e) {\n            // If the pull fails due to system traffic throttling or other reasons, the consumer must re-initiate the request to obtain the message. \n            e.printStackTrace();\n        }\n')),(0,a.kt)("h2",{id:"usage-notes"},"Usage notes"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Use serial consumption to prevent out-of-order message processing.")),(0,a.kt)("p",null,"We recommend that you use serial message consumption instead of batch consumption. Consumption of multiple messages at the same time may cause out-of-order message processing."),(0,a.kt)("p",null,"For example, messages 1, 2, 3, and 4 are sent in the 1-2-3-4 order and the order of batch consumption is 1-","[","2, 3","]","(processed in batches but failed)-","[","2, 3","]","(retry)-4. The system may repeatedly process Message 2 if Message 3 fails to be processed. As a result, out-of-order message consumption occurs."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Avoid including a large number of messages in a message group.")),(0,a.kt)("p",null,"Apache RocketMQ ensures that the messages in the same message group are stored in the same queue. A message group that contains a large number of messages causes the corresponding queue to be overloaded. This affects messaging performance and hinders scalability. When you configure message groups, you can use order IDs and user IDs as the message sequencing conditions. This ensures the order of messages of the same user."),(0,a.kt)("p",null,"We recommend that you split messages in your business applications by message group. For example, you can use order IDs and user IDs as message group keywords to implement ordered processing of messages of the same user. You do not need to ensure the order of messages of different users."))}c.isMDXComponent=!0},20521:(e,s,t)=>{t.d(s,{Z:()=>r});const r=t.p+"assets/images/fifo_trade-a8bac55b8fb3fceb995891c64c2f0a5a.png"},13638:(e,s,t)=>{t.d(s,{Z:()=>r});const r=t.p+"assets/images/fifomessagegroup-aad0a1b7e64089075db956c0eca0cbf4.png"},43493:(e,s,t)=>{t.d(s,{Z:()=>r});const r=t.p+"assets/images/lifecyclefornormal-e8a2a7e42a0722f681eb129b51e1bd66.png"},40046:(e,s,t)=>{t.d(s,{Z:()=>r});const r=t.p+"assets/images/tradewithfifo-30884dfeb909c54d7379641fcec437fa.png"},57939:(e,s,t)=>{t.d(s,{Z:()=>r});const r=t.p+"assets/images/tradewithnormal-5273283ffa54ec08017f356227411f83.png"}}]);