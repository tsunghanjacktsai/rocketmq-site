"use strict";(self.webpackChunkrocketmq_docs=self.webpackChunkrocketmq_docs||[]).push([[9938],{3905:(e,s,n)=>{n.d(s,{Zo:()=>u,kt:()=>g});var a=n(67294);function o(e,s,n){return s in e?Object.defineProperty(e,s,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[s]=n,e}function t(e,s){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);s&&(a=a.filter((function(s){return Object.getOwnPropertyDescriptor(e,s).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var s=1;s<arguments.length;s++){var n=null!=arguments[s]?arguments[s]:{};s%2?t(Object(n),!0).forEach((function(s){o(e,s,n[s])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):t(Object(n)).forEach((function(s){Object.defineProperty(e,s,Object.getOwnPropertyDescriptor(n,s))}))}return e}function i(e,s){if(null==e)return{};var n,a,o=function(e,s){if(null==e)return{};var n,a,o={},t=Object.keys(e);for(a=0;a<t.length;a++)n=t[a],s.indexOf(n)>=0||(o[n]=e[n]);return o}(e,s);if(Object.getOwnPropertySymbols){var t=Object.getOwnPropertySymbols(e);for(a=0;a<t.length;a++)n=t[a],s.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=a.createContext({}),l=function(e){var s=a.useContext(c),n=s;return e&&(n="function"==typeof e?e(s):r(r({},s),e)),n},u=function(e){var s=l(e.components);return a.createElement(c.Provider,{value:s},e.children)},m="mdxType",d={inlineCode:"code",wrapper:function(e){var s=e.children;return a.createElement(a.Fragment,{},s)}},p=a.forwardRef((function(e,s){var n=e.components,o=e.mdxType,t=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=l(n),p=o,g=m["".concat(c,".").concat(p)]||m[p]||d[p]||t;return n?a.createElement(g,r(r({ref:s},u),{},{components:n})):a.createElement(g,r({ref:s},u))}));function g(e,s){var n=arguments,o=s&&s.mdxType;if("string"==typeof e||o){var t=n.length,r=new Array(t);r[0]=p;var i={};for(var c in s)hasOwnProperty.call(s,c)&&(i[c]=s[c]);i.originalType=e,i[m]="string"==typeof e?e:o,r[1]=i;for(var l=2;l<t;l++)r[l]=n[l];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}p.displayName="MDXCreateElement"},15260:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>t,metadata:()=>i,toc:()=>l});var a=n(87462),o=(n(67294),n(3905));const t={},r="Consumer Load Balancing",i={unversionedId:"featureBehavior/08consumerloadbalance",id:"version-5.0/featureBehavior/08consumerloadbalance",title:"Consumer Load Balancing",description:"When consumers in a consumer group pull messages from a Apache RocketMQ topic, a load balancing policy is used to determine how the messages are allocated to the consumers. Load balancing policies improve service concurrency and application scalability. This topic describes the load balancing policies that Apache RocketMQ provides for consumers.",source:"@site/i18n/en/docusaurus-plugin-content-docs/version-5.0/04-featureBehavior/08consumerloadbalance.md",sourceDirName:"04-featureBehavior",slug:"/featureBehavior/08consumerloadbalance",permalink:"/docs/featureBehavior/08consumerloadbalance",draft:!1,editUrl:"https://github.com/apache/rocketmq-site/tree/new-official-website/versioned_docs/version-5.0/04-featureBehavior/08consumerloadbalance.md",tags:[],version:"5.0",frontMatter:{},sidebar:"version-5.0/myAutogeneratedSidebar",previous:{title:"Message Filtering",permalink:"/docs/featureBehavior/07messagefilter"},next:{title:"Consumer Progress Management",permalink:"/docs/featureBehavior/09consumerprogress"}},c={},l=[{value:"Background information",id:"background-information",level:2},{value:"Broadcast consumption and cluster consumption",id:"broadcast-consumption-and-cluster-consumption",level:2},{value:"Introduction to the load balancing policy for consumers",id:"introduction-to-the-load-balancing-policy-for-consumers",level:2},{value:"Message-based load balancing",id:"message-based-load-balancing",level:2},{value:"Queue-based load balancing",id:"queue-based-load-balancing",level:2},{value:"Version compatibility",id:"version-compatibility",level:2},{value:"Usage notes",id:"usage-notes",level:2}],u={toc:l},m="wrapper";function d(e){let{components:s,...t}=e;return(0,o.kt)(m,(0,a.Z)({},u,t,{components:s,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"consumer-load-balancing"},"Consumer Load Balancing"),(0,o.kt)("p",null,"When consumers in a consumer group pull messages from a Apache RocketMQ topic, a load balancing policy is used to determine how the messages are allocated to the consumers. Load balancing policies improve service concurrency and application scalability. This topic describes the load balancing policies that Apache RocketMQ provides for consumers."),(0,o.kt)("h2",{id:"background-information"},"Background information"),(0,o.kt)("p",null,"Familiarizing yourself with the load balancing policies provided by Apache RocketMQ can help you determine the appropriate measures to take when confronted with the following scenarios:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Disaster recovery: You can determine how messages are retried and switched over when local nodes fail.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Message ordering: You can better understand how Apache RocketMQ ensures strict first-in-first-out message ordering.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},"Horizontal partitioning: You can plan for traffic migration and horizontal scaling operations based on how messages are allocated."))),(0,o.kt)("h2",{id:"broadcast-consumption-and-cluster-consumption"},"Broadcast consumption and cluster consumption"),(0,o.kt)("p",null,"Apache RocketMQ allows multiple consumer groups to subscribe to the same message and each consumer group to initialize multiple consumers. Consumer groups and consumers can be configured to consume messages in the following scenarios:",(0,o.kt)("img",{alt:"Consumption modes",src:n(18477).Z,width:"2375",height:"822"})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Broadcast consumption across consumer groups")," : This scenario is illustrated on the left side of the preceding figure. Each consumer group initializes its own consumer who consumes all messages. Messages are delivered to multiple subscribers from topics in a one-to-many relationship."),(0,o.kt)("p",{parentName:"li"},"This mode is typically used in scenarios such as gateway push and configuration push."))),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Cluster consumption within a consumer group")," : This scenario is illustrated on the right side of the preceding figure. Each consumer group initializes multiple consumers, and the messages are sent to all consumers in the group. This is useful when you want to implement horizontal traffic partitioning and load balancing within the group."),(0,o.kt)("p",{parentName:"li"},"This mode is suitable for microservice decoupling."))),(0,o.kt)("h2",{id:"introduction-to-the-load-balancing-policy-for-consumers"},"Introduction to the load balancing policy for consumers"),(0,o.kt)("p",null,"In scenarios that use broadcast consumption, load balancing is not required because each consumer group contains only one consumer."),(0,o.kt)("p",null,"However, in scenarios that use cluster consumption, each consumer group contains multiple consumers. Load balancing policies can help determine how messages are allocated."),(0,o.kt)("p",null,"Based on consumer types, load balancing policies can be divided into the following two types:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"#section-x2b-2cu-gpf"},"Message-based load balancing"),": the default policy for push consumers and simple consumers.")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("a",{parentName:"p",href:"#section-n9m-6xy-y77"},"Queue-based load balancing"),": the default policy for pull consumers."))),(0,o.kt)("h2",{id:"message-based-load-balancing"},"Message-based load balancing"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Usage scope")),(0,o.kt)("p",null,"Message-based load balancing is the only and default policy for push consumers and simple consumers."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Working mechanism")),(0,o.kt)("p",null,"Message-based load balancing evenly allocates messages in a topic to multiple consumers in a consumer group.\n",(0,o.kt)("img",{alt:"Message-based load balancing",src:n(9138).Z,width:"1266",height:"387"})),(0,o.kt)("p",null,"As shown in the preceding figure, Consumer Group A consists of three consumers: A1, A2, and A3. These three consumers consume the messages of Queue1 in the topic."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Message-based load balancing ensures that messages in a queue can be concurrently processed by multiple consumers. However, messages are randomly sent to consumers, which means that you cannot specify how messages are allocated to consumers.")),(0,o.kt)("p",null,"Message-based load balancing is based on the acknowledgment semantics of a single message in a topic. After a consumer receives a message, the broker locks the message to ensure that it is invisible to other consumers until it is consumed or times out. This prevents messages of the same queue to be consumed multiple times by different consumers."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Load policy for ordered messages")),(0,o.kt)("p",null,"In ordered messages, the order of messages refers to the sequence of multiple messages in a message group. These messages must be processed in the exactly same order as they are stored on the broker. Therefore, message-based load balancing needs to ensure that messages in a message group are consumed in the same order as they are stored on the server. When different consumers process messages in the same group, the system locks the messages in strict accordance with the message order to ensure messages are consumed sequentially.\n",(0,o.kt)("img",{alt:"Load policy for ordered messages",src:n(57595).Z,width:"1439",height:"641"})),(0,o.kt)("p",null,"In the preceding figure, there are four ordered messages in message group G1 of Queue1. Their saving orders are represented by M1 to M4. During consumption, when the messages M1 and M2 are processed by consumer A1, consumer A2 cannot consume messages M3 and M4 in parallel if the consumption status for M1 and M2 is not submitted. Consumers can only consume messages when the consumption status for preceding messages is submitted."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Features")),(0,o.kt)("p",null,"Compared with queue-based load balancing, message-based load balancing has the following features:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"More balanced consumption allocationIn conventional queue-based load balancing, the number of queues and the number of consumers may not be properly balanced. This results in a system where some consumers may be idle while some consumers are overburdened. In comparison, message-based load balancing ensures even load balancing among consumers without requiring you to manage the number of queues and consumers.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"More forgiving to differences in networking capacitiesIn an online production environment, the processing capabilities of consumers may be different due to actual network conditions or inconsistent networking hardware specifications. If messages are allocated based on queues, there might be cases where some consumers have accumulated messages while some other consumers are idle. In contrast, message-based load balancing allocates messages on demand to achieve a more balanced load distribution among consumers.")),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Easier O\\&M for queue allocationIn scenarios where conventional queue-based load balancing is used, you must make sure that the number of queues is greater or equal to the number of consumers to ensure that no consumers are idle. This issue is not present with message-based load balancing.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Scenarios")),(0,o.kt)("p",null,"Since messages in a queue are discretely allocated to consumers, message-based load balancing is suitable for most online event handling scenarios. In these scenarios, consumers require only basic processing capabilities instead of batch aggregation of messages. As for scenarios such as stream processing and aggregation computing where aggregation and batch processing of messages is required, queue-based load balancing is a better choice.\n",(0,o.kt)("strong",{parentName:"p"},"Example")),(0,o.kt)("p",null,"Consumers do not need to perform extra configurations for message-based load balancing. By default, this policy is enabled for push consumers and simple consumers."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-java"},"        SimpleConsumer simpleConsumer = null;\n        // Consumption example 1: When push consumers consume normal messages, they need only to process messages on a message listener and do not need to consider load balancing. \n        MessageListener messageListener = new MessageListener() {\n            @Override\n            public ConsumeResult consume(MessageView messageView) {\n                System.out.println(messageView);\n                // Return the status based on the consumption result. \n                return ConsumeResult.SUCCESS;\n            }\n        };\n        // Consumption example 2: When simple consumers consume normal messages, they obtain and submit messages. The consumers obtain messages based on the subscribed topic and do not need to consider load balancing. \n        List<MessageView> messageViewList = null;\n        try {\n            messageViewList = simpleConsumer.receive(10, Duration.ofSeconds(30));\n            messageViewList.forEach(messageView -> {\n                System.out.println(messageView);\n                // After consumption is complete, consumers must invoke ACK to submit the consumption result. \n                try {\n                    simpleConsumer.ack(messageView);\n                } catch (ClientException e) {\n                    e.printStackTrace();\n                }\n            });\n        } catch (ClientException e) {\n            // If the pull fails due to system traffic throttling or other reasons, consumers must re-initiate the request to obtain the message. \n            e.printStackTrace();\n        }\n")),(0,o.kt)("h2",{id:"queue-based-load-balancing"},"Queue-based load balancing"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Usage scope")),(0,o.kt)("p",null,"For consumers of broker versions 4.x and 3.x, including PullConsumer, DefaultPushConsumer, DefaultPullConsumer and DefaultLitePullConsumer, only queue-based load balancing can be used."),(0,o.kt)("p",null,"Working mechanism"),(0,o.kt)("p",null,"In the queue-based load balancing policy, consumers in the same consumer group consume messages in the queue allocated to them. Each queue is consumed by one consumer.\n",(0,o.kt)("img",{alt:"\u961f\u5217\u7ea7\u8d1f\u8f7d\u5747\u8861\u539f\u7406",src:n(20256).Z,width:"1375",height:"672"})),(0,o.kt)("p",null,"As shown in the preceding figure, the three queues (Queue1, Queue2, and Queue3) in the topic are assigned to two consumers in a consumer group. Since each queue can be assigned to only one consumer, consumer A2 is assigned two queues. If the number of queues is less than the number of consumers, some consumers will not have queues assigned to them."),(0,o.kt)("p",null,"Queue-based load balancing allocates messages based on operating data such as the number of queues and the number of consumers. Each queue is bound to a specific consumer. Then, each consumer processes messages according to the consumption semantics of obtaining messages ",">"," submitting offsets ",">"," persisting offsets. The consumption status is not returned to the queue when consumers obtain messages. Therefore, to avoid repeated consumption of messages by multiple consumers, each queue can be consumed by only one consumer."),(0,o.kt)("admonition",{type:"note"},(0,o.kt)("p",{parentName:"admonition"},"Queue-based load balancing guarantees that a queue is processed by only one consumer. However, the implementation of this policy depends on the information negotiation mechanism between the consumer and the broker. "),(0,o.kt)("p",{parentName:"admonition"},"Apache RocketMQ does not guarantee that messages in a queue are processed by only one consumer. Therefore, when the number of consumers and the number of queues change, temporary inconsistency in queue allocation may occur, which causes a small number of messages to be processed more than once.")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Features")),(0,o.kt)("p",null,"Compared with message-based load balancing, the granularity of queue-based load balancing is larger and less flexible. However, queue-based load balancing is ideal for stream processing scenarios. It ensures that messages in a queue are processed by one consumer. Therefore, queue-based load balancing is more suitable for scenarios where you want to process aggregated messages or messages in batches."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Scenarios")),(0,o.kt)("p",null,"Queue-based load balancing is applicable to scenarios where you want to process aggregated messages or messages in batches. These are common scenarios in stream computing and data aggregation applications."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Example")),(0,o.kt)("p",null,"Consumers do not need to perform extra configurations for queue-based load balancing. By default, this policy is enabled for pull consumers of broker versions 4.x and 3.x."),(0,o.kt)("p",null,"For more information about the sample code, visit the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/apache/rocketmq/blob/develop/example/src/main/java/org/apache/rocketmq/example/simple/LitePullConsumerAssign.java"},"code library of Apache RocketMQ"),"."),(0,o.kt)("h2",{id:"version-compatibility"},"Version compatibility"),(0,o.kt)("p",null,"The message-based load balancing policy is available from broker version 5.0 of Apache RocketMQ. For broker versions 4.x and 3.x, only the queue-based load balancing policy is available."),(0,o.kt)("p",null,"Both the message-based and queue-based load balancing policies are available for broker version 5.x of Apache RocketMQ. Which policy is effective depends on the client version and consumer type."),(0,o.kt)("h2",{id:"usage-notes"},"Usage notes"),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Implement message idempotence for consumption logic.")),(0,o.kt)("p",null,"Both the message-based and queue-based load balancing policies trigger temporary re-balancing in scenarios such as adding consumers, removing consumers, and broker scaling. This may cause temporary load inconsistency and result in a small number of messages being consumed more than once. Therefore, it is necessary to perform deduplication to ensure idempotence for message consumption."))}d.isMDXComponent=!0},9138:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/clustermode-dfd781d08bc0c69111841bda537aa302.png"},20256:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/clusterqueuemode-ce4f88dc594c1237ba95db2fa9146b8c.png"},18477:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/consumemode-74d53c59b3266f1f633b1392f5a0f279.png"},57595:(e,s,n)=>{n.d(s,{Z:()=>a});const a=n.p+"assets/images/fifoinclustermode-60b2f917ab49333f93029cee178b13f0.png"}}]);