"use strict";(self.webpackChunkrocketmq_docs=self.webpackChunkrocketmq_docs||[]).push([[2265],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>h});var r=n(67294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,i=function(e,t){if(null==e)return{};var n,r,i={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},d="mdxType",v={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},p=r.forwardRef((function(e,t){var n=e.components,i=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=c(n),p=i,h=d["".concat(l,".").concat(p)]||d[p]||v[p]||o;return n?r.createElement(h,a(a({ref:t},u),{},{components:n})):r.createElement(h,a({ref:t},u))}));function h(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var o=n.length,a=new Array(o);a[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s[d]="string"==typeof e?e:i,a[1]=s;for(var c=2;c<o;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}p.displayName="MDXCreateElement"},37536:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>a,default:()=>v,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var r=n(87462),i=(n(67294),n(3905));const o={},a="RocketMQ EventBridge Core Concept",s={unversionedId:"eventbridge/01RocketMQEventBridgeConcepts",id:"eventbridge/01RocketMQEventBridgeConcepts",title:"RocketMQ EventBridge Core Concept",description:"Understanding the core concepts in EventBridge can help us better analyze and use EventBridge. This article focuses on introducing the terms included in EventBridge:",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/07-eventbridge/01RocketMQEventBridgeConcepts.md",sourceDirName:"07-eventbridge",slug:"/eventbridge/01RocketMQEventBridgeConcepts",permalink:"/docs/4.x/eventbridge/01RocketMQEventBridgeConcepts",draft:!1,editUrl:"https://github.com/apache/rocketmq-site/tree/new-official-website/docs/07-eventbridge/01RocketMQEventBridgeConcepts.md",tags:[],version:"current",frontMatter:{},sidebar:"myAutogeneratedSidebar",previous:{title:"Server Configuration",permalink:"/docs/4.x/parameterConfiguration/02server"},next:{title:"RocketMQ EventBridge Overview",permalink:"/docs/4.x/eventbridge/02RocketMQEventBridgeOverview"}},l={},c=[{value:"EventSource",id:"eventsource",level:2},{value:"EventBus",id:"eventbus",level:2},{value:"EventRule",id:"eventrule",level:2},{value:"FilterPattern",id:"filterpattern",level:2},{value:"Transform",id:"transform",level:2},{value:"EventTarget",id:"eventtarget",level:2}],u={toc:c},d="wrapper";function v(e){let{components:t,...o}=e;return(0,i.kt)(d,(0,r.Z)({},u,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"rocketmq-eventbridge-core-concept"},"RocketMQ EventBridge Core Concept"),(0,i.kt)("p",null,"Understanding the core concepts in EventBridge can help us better analyze and use EventBridge. This article focuses on introducing the terms included in EventBridge:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"EventSource: the source of the event. Used to manage events sent to EventBridge, all events sent to EventBridge must be marked with the source name information, corresponding to the source field in the CloudEvent event body."),(0,i.kt)("li",{parentName:"ul"},"EventBus: the event bus. Used to store events sent to EventBridge."),(0,i.kt)("li",{parentName:"ul"},"EventRule: event rule. When a consumer needs to subscribe to events, they can configure filtering and transformation information through rules to push events to the designated target endpoint."),(0,i.kt)("li",{parentName:"ul"},"FilterPattern: event filtering pattern, used to configure filtering of target endpoints in rules."),(0,i.kt)("li",{parentName:"ul"},"Transform: event transformation, converting the event format to the data format required by the target endpoint."),(0,i.kt)("li",{parentName:"ul"},"EventTarget: the target endpoint of the event, which is the actual event consumer.")),(0,i.kt)("p",null,"Next, we will expand on these concepts in more detail."),(0,i.kt)("h2",{id:"eventsource"},"EventSource"),(0,i.kt)("p",null,"Event source represents the origin of the event and is used to describe a category of events, generally corresponding one-to-one with microservice systems. For example: transaction event source, attendance event source, etc. Event source is a large classification for events, and a single event source often contains multiple event types (type), such as a transaction event source may contain: order events, payment events, refund events, etc."),(0,i.kt)("p",null,'Additionally, it is worth noting that event source is not used to describe the entity that caused the event. Instead, in CloudEvent, we generally use subject to represent the entity resource that caused the event. The event source is similar to the large category divisions in a market economy department store, such as fresh food area, daily necessities area, household appliances area, etc. In the event center "department store", we can quickly find the event we need through the event source.'),(0,i.kt)("h2",{id:"eventbus"},"EventBus"),(0,i.kt)("p",null,"The event bus is where events are stored, and it can have multiple implementations including Local, RocketMQ, Kafka, etc."),(0,i.kt)("p",null,"When the event producer sends an event, they must specify the event bus. The event bus is a first-class citizen in EventBridge, and all other resources form logical isolation around the event bus, that is: event sources and event rules must belong to a specific event bus. Event sources and event rules under different event buses can have the same name, but event sources and rules under the same event bus must have unique names."),(0,i.kt)("h2",{id:"eventrule"},"EventRule"),(0,i.kt)("p",null,"When a consumer needs to subscribe to events, they can configure filtering and transformation information through event rules, and push events to the designated target endpoint. Therefore, event rules include three parts: event filtering + event transformation + event target."),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"img_1.png",src:n(78732).Z,width:"572",height:"360"})),(0,i.kt)("h2",{id:"filterpattern"},"FilterPattern"),(0,i.kt)("p",null,"By using event filtering patterns, we can filter events on the event bus and only push the events that the target endpoint needs, thus reducing unnecessary opening and relieving the pressure on the consumer's target endpoint. Currently, EventBridge supports the following event filtering capabilities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Specified value matching"),(0,i.kt)("li",{parentName:"ul"},"Prefix matching"),(0,i.kt)("li",{parentName:"ul"},"Suffix matching"),(0,i.kt)("li",{parentName:"ul"},"Exclusion matching"),(0,i.kt)("li",{parentName:"ul"},"Numeric matching"),(0,i.kt)("li",{parentName:"ul"},"Array matching"),(0,i.kt)("li",{parentName:"ul"},"And complex combination logic matching")),(0,i.kt)("p",null,"(Details will be covered in other articles)"),(0,i.kt)("h2",{id:"transform"},"Transform"),(0,i.kt)("p",null,"Event producers' events may be subscribed to by multiple consumers, but the data format needed by different consumers is often different. In this case, it is necessary to convert the event produced by the producer into the event format that the consumer target end needs. Currently, EventBridge supports the following event conversion capabilities:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Complete events: No conversion, directly delivering the original CloudEvents;"),(0,i.kt)("li",{parentName:"ul"},"Partial events: Extracting the content that needs to be delivered to the event target through JsonPath syntax from CloudEvents;"),(0,i.kt)("li",{parentName:"ul"},"Constants: The event only serves as a trigger, and the delivered content is a constant;"),(0,i.kt)("li",{parentName:"ul"},"Template converter: Flexibly rendering the delivered event format through the definition of a template.")),(0,i.kt)("p",null,"(Details to be seen in other articles)"),(0,i.kt)("h2",{id:"eventtarget"},"EventTarget"),(0,i.kt)("p",null,"The event target is the event consumer in the EventBridge architecture. In this architecture, consumers only need to design their own business models and provide a common API (this API can be used to receive events and also for front-end management operations). EventBridge will then safely and reliably push events to the target consumer according to the data format defined by the API."))}v.isMDXComponent=!0},78732:(e,t,n)=>{n.d(t,{Z:()=>r});const r=n.p+"assets/images/EventRule-c822b08589be43f273884c8b21bcb7de.png"}}]);